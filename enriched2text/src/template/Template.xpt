«IMPORT EnrichedModel»

«DEFINE main FOR EnrichedModel»
«EXPAND javaClass(this) FOREACH instanceTypes»
«ENDDEFINE»

«DEFINE javaClass(EnrichedModel model) FOR InstanceType»
«FILE name+".java"»package «model.packageName»;
		«IF model.methodParameters.typeSelect(Thread).exists(e|e.instanceType==this && e.isMultiple)»
		import java.util.*;
		
		«ENDIF-»
        public class «name» {
        	«EXPAND staticField FOREACH model.methodParameters.select(e|e.isStatic && e.instanceType==this)»
            «EXPAND method(model) FOREACH methods»
        }
    «ENDFILE»
«ENDDEFINE»

«DEFINE staticField FOR MethodParameter»
«ERROR 'Should not happen'»
«ENDDEFINE»
«DEFINE staticField FOR Thread»
«IF this.isMultiple-»
public static List<Thread> «this.name» = new LinkedList<Thread>();
«ELSE-»
public static Thread «this.name» = null;
«ENDIF-»
«ENDDEFINE»
«DEFINE staticField FOR Instance»
public static «this.instanceType.name» «this.name» = new «this.instanceType.name»();
«ENDDEFINE»
«DEFINE staticField FOR SharedResource»
public static Object «this.name» = new Object();
«ENDDEFINE»

«DEFINE method(EnrichedModel model) FOR Method»
public «IF isStatic»static «ENDIF»void «name»(«IF this.name == 'main'»String[] args«ELSE»«IF hasDynamicFirstState»int initialState, «ENDIF»«EXPAND methodParameter FOREACH parameters SEPARATOR ', '»«ENDIF»)
	«IF interruption == 2» throws InterruptedException «ENDIF-»{
    «IF hasDynamicFirstState-»
    int state = initialState;
    «ELSEIF states.size > 0-»
    int state = «defaultFirstState.id-»;
    «ENDIF-»
    «IF this.variables.size > 0 -»
    «EXPAND methodParameter FOREACH this.variables SEPARATOR '=null;' -»=null;
    «ENDIF-»
    «EXPAND synchronizationBegin FOREACH lockedResources-»
    «IF states.size > 0 -»
    while (state > 0) {
    	«IF interruption == 1-»
		try{
		«ENDIF-»
        switch (state) {
		    «EXPAND state(this) FOREACH states-»
		}
		«IF interruption == 1»
		} catch (InterruptedException e) {
			«IF model.methodParameters.typeSelect(Thread).exists(e|e.name == this.name && e.isMultiple)»synchronized («model.methodParameters.selectFirst(e|e.name == this.name).instanceType.name».«this.name») {
				«model.methodParameters.selectFirst(e|e.name == this.name).instanceType.name».«this.name».remove(this);
			}«ENDIF-»
			state = «this.stateOnInterruption.id»;
		}
		«ENDIF-»
    }
    «ELSE»//TODO stub«ENDIF»
    «EXPAND synchronizationEnd FOREACH lockedResources-»
}
«ENDDEFINE»

«DEFINE methodParameter FOR MethodParameter»«ERROR "Should not happen!"» «ENDDEFINE»
«DEFINE methodParameter FOR Thread»Thread «this.name»«ENDDEFINE»
«DEFINE methodParameter FOR Instance»«this.instanceType.name» «this.name»«ENDDEFINE»
«DEFINE methodParameter FOR SharedResource»Object «this.name»«ENDDEFINE»

«DEFINE synchronizationBegin FOR SharedResource -»
    synchronized («this.name») {
«ENDDEFINE»
«DEFINE synchronizationEnd FOR SharedResource -»
    }
«ENDDEFINE»

«DEFINE state(Method method) FOR State-»
case «this.id-»:
	«EXPAND stateImpl(method) FOR this-»
	«IF jumps.size>1»
	«EXPAND jump FOREACH jumps.select(e|e != jumps.last())» state = «IF jumps.last().nextState != null»«jumps.last().nextState.id»«ELSE»0«ENDIF»;
	«ELSEIF jumps.size==1»
	state = «IF jumps.first().nextState != null»«jumps.first().nextState.id»«ELSE»0«ENDIF»;
	«ELSE»
	state = 0;
	«ENDIF-»
	break;
«ENDDEFINE»
«DEFINE jump FOR Jump»if (true /*TODO "«condition»"*/) state = «IF nextState != null»«nextState.id»«ELSE»0«ENDIF»;
else 
«ENDDEFINE»

«DEFINE stateImpl(Method method) FOR State-»
«ENDDEFINE»
«DEFINE stateImpl(Method method) FOR MethodCallState-»
«IF this.targetInstance == null-»
Main.«ELSEIF method.parameters.contains(this.targetInstance)-»
«this.targetInstance.name».«ELSE-»
this.«ENDIF»
«this.calledMethod.name-»
(«IF this.calledMethod.hasDynamicFirstState»«this.firstState.id», «ENDIF-»
«EXPAND parameterInMethodCall(method) FOREACH this.calledMethod.parameters SEPARATOR ', '»);
«ENDDEFINE»
«DEFINE stateImpl(Method method) FOR YieldState-»
Thread.yield();
«ENDDEFINE»
«DEFINE stateImpl(Method method) FOR SleepState-»
«IF method.interruption == 2»
Thread.sleep(«this.duration»);
«ELSE»
try{
	Thread.sleep(«this.duration»);
} catch (InterruptedException e) {
	e.printStackTrace();
}
«ENDIF»
«ENDDEFINE»
«DEFINE stateImpl(Method method) FOR ForkState»
«EXPAND forkThread(method) FOREACH this.threadInits»
«ENDDEFINE»

«DEFINE forkThread(Method method) FOR ThreadInit»
	{«EXPAND finalThreadParam(method) FOREACH thread.calledMethod.parameters-»
	«IF this.thread.targetInstance != null-»
	«EXPAND finalThreadParam(method) FOR thread.targetInstance-»
	«ENDIF-»
	«IF this.thread.isStatic-»
	«IF this.thread.isMultiple-»
	Thread $t = new Thread(new Runnable(){
		public void run(){
		«EXPAND threadInit(method) FOR this»
		}
	});
	
	synchronized («this.thread.instanceType.name».«this.thread.name») {
		«this.thread.instanceType.name».«this.thread.name».add($t);
	}
	
	$t.start();«ELSE»
	«this.thread.instanceType.name».«this.thread.name»= new Thread(new Runnable(){
	public void run(){
	«EXPAND threadInit(method) FOR this»
	}});
	«ENDIF»
	«ELSE»
	«this.thread.name»= new Thread(new Runnable(){
	public void run(){
	«EXPAND threadInit(method) FOR this»
	}});
	«this.thread.name».start();
	«ENDIF-»
	}
«ENDDEFINE»

«DEFINE stateImpl(Method method) FOR JoinState-»
«IF method.interruption == 2»
«EXPAND joinThread FOREACH joinedThreads»
«ELSE-»
try{
	«EXPAND joinThread FOREACH joinedThreads»
} catch (InterruptedException e) {
	e.printStackTrace();
}
«ENDIF»
«ENDDEFINE»

«DEFINE joinThread FOR Thread-»
«IF this.isStatic-»
«IF this.isMultiple-»{
	Thread $t;
	synchronized («this.instanceType.name».«this.name») {
		$t = «this.instanceType.name».«this.name».get(«this.instanceType.name».«this.name».size() - 1);
	}
	$t.join();
}«ELSE-»
«this.instanceType.name».«this.name».join();
«ENDIF-»
«ELSE-»
«this.name».join();
«ENDIF-»
«ENDDEFINE»

«DEFINE stateImpl(Method method) FOR InterruptState-»
«IF interruptedThread.isStatic-»
«IF interruptedThread.isMultiple-»
synchronized («interruptedThread.instanceType.name».«interruptedThread.name») {
	for (Thread $t : «interruptedThread.instanceType.name».«interruptedThread.name») {
		$t.interrupt();
	}
	«interruptedThread.name».clear();
}
«ELSE-»
if («interruptedThread.instanceType.name».«interruptedThread.name» != null) {
	«interruptedThread.instanceType.name».«interruptedThread.name».interrupt();
}«ENDIF-»
«ELSE»if («interruptedThread.name» != null) {
	«interruptedThread.name».interrupt();
}«ENDIF-»
«ENDDEFINE»

«DEFINE parameterInMethodCall(Method method) FOR MethodParameter-»
«IF method.parameters.contains(this) || method.variables.contains(this)»
«this.name»«ELSEIF this.isStatic-»
«this.instanceType.name».«this.name-»
«ELSE-»
this«ENDIF-»
«ENDDEFINE»

«DEFINE threadInit(Method method) FOR ThreadInit-»
«IF this.thread.targetInstance == null-»
Main.«ELSE-»
«this.thread.targetInstance.name+'$final'».
«ENDIF-»
«this.thread.calledMethod.name-»
(«IF this.thread.calledMethod.hasDynamicFirstState»«this.thread.firstState.id», «ENDIF-»
«EXPAND finalParameterInThreadInit(method) FOREACH this.thread.calledMethod.parameters SEPARATOR ', '-»);«ENDDEFINE»

«DEFINE finalParameterInThreadInit(Method method) FOR MethodParameter-»
«this.name+ '$final'»«ENDDEFINE»

«DEFINE finalThreadParam(Method method) FOR MethodParameter-»
«ERROR 'Should not happen'»
«ENDDEFINE»
«DEFINE finalThreadParam(Method method) FOR SharedResource-»
final Object «this.name + '$final'» = «this.name»; 
«ENDDEFINE»
«DEFINE finalThreadParam(Method method) FOR Thread-»
final Thread «this.name + '$final'» = «this.name»;
«ENDDEFINE»
«DEFINE finalThreadParam(Method method) FOR Instance-»
final «this.instanceType.name» «this.name + '$final'» = «IF method.parameters.contains(this) || method.variables.contains(this)»«this.name»«ELSEIF this.isStatic»«this.instanceType.name».«this.name»«ELSE»this«ENDIF»;
«ENDDEFINE»


