module ModelTransformation;
create OUT: EnrichedModel from IN: BasicModel;

rule basic2Enriched {
	from
		basicModel: BasicModel!BasicModel
	to
		enrichedModel: EnrichedModel!EnrichedModel(
			instanceTypes <- basicModel.instanceTypes->including(DefaultInstanceType),
			methodParameters <- basicModel.instances
			                ->including(ThreadReference)
							->union(BasicModel!ForkedThread.allInstances()->collect(i|thisModule.resolveTemp(i, 'ThreadReference')))
							->union(basicModel.resources)
		),
		DefaultInstanceType: EnrichedModel!InstanceType(
			name <- 'Main',
			methods <- Set{ProgramEntryPoint}
				->union(BasicModel!NamedActivity.allInstances()->select(e|e.getInstanceType()=OclUndefined)->collect(e|thisModule.resolveTemp(e, 'SimpleMethod')))
				->union(BasicModel!BasicModel.allInstances()->asSequence()->first().forkedThreads->collect(e|thisModule.resolveTemp(e, 'ForkedThreadMethod')))
		),
		ProgramEntryPoint: EnrichedModel!Method(
			name <- 'main',
			states <- basicModel.activities
		),
		ThreadReference: EnrichedModel!Thread(
			name<-basicModel.name
		)
}

--Instance
rule instanceType2instanceType {
	from
		instanceTypeBasic: BasicModel!InstanceType
	to
		instanceTypeEnriched: EnrichedModel!InstanceType(
			name <- instanceTypeBasic.name,
			methods <- BasicModel!NamedActivity.allInstances()->select(e|e.getInstanceType()=instanceTypeBasic)->collect(e|thisModule.resolveTemp(e, 'SimpleMethod'))
				->union(instanceTypeBasic.forkedThreads->collect(e|thisModule.resolveTemp(e, 'ForkedThreadMethod')))
		)
}

helper context BasicModel!Activity def: getInstanceType(): BasicModel!InstanceType =
	if self.instance.oclIsUndefined() then OclUndefined else self.instance.instanceType endif
;

rule instance2instance {
	from
		instanceBasic: BasicModel!Instance
	to
		instanceEnriched: EnrichedModel!Instance(
			name<-instanceBasic.name,
			instanceType <- instanceBasic.instanceType	
		)
}


rule sharedResources2sharedResources{
	from
		resourceBasic: BasicModel!SharedResource
	to
		resourceEnriched: EnrichedModel!SharedResource(
			name<-resourceBasic.name	
		)
}

--Activities to states
abstract rule linearActivity2State{
	from
		linearactivity: BasicModel!LinearActivity
	to
		state: EnrichedModel!State(
			jumps<-Set{linearactivity.nextActivity}->iterate(e; result: Set(EnrichedModel!Activity) = Set{} | if e.oclIsKindOf(BasicModel!End) then result else result->including(thisModule.nextActivity2Jump(e)) endif),
			id<-linearactivity.stateId
		)
}

lazy rule nextActivity2Jump{
	from
		activity: BasicModel!Activity
	to
		jump: EnrichedModel!Jump(
			nextState<-activity
		)
}

rule simpleActivity2State extends linearActivity2State{
	from
		linearactivity: BasicModel!SimpleActivity
	to
		state: EnrichedModel!MethodCallState(
			calledMethod <- SimpleMethod,
			targetInstance <- linearactivity.instance
		),
		SimpleMethod: EnrichedModel!Method(
			name <- linearactivity.activityName + '(simple method)'
		)
}

rule nestedActivity2State extends linearActivity2State{
	from
		linearactivity: BasicModel!NestedActivity
	to
		state: EnrichedModel!MethodCallState(
			calledMethod <- SimpleMethod,
			targetInstance <- linearactivity.instance
			
		),
		SimpleMethod: EnrichedModel!Method(
			name <- linearactivity.activityName + '(nested method)',
			states <- linearactivity.nestedThread.activities
		)
}

rule sleepActivity2SleepState  extends linearActivity2State {
	from
		linearactivity: BasicModel!Sleep
	to
		state: EnrichedModel!SleepState
}

rule yieldActivity2YieldState  extends linearActivity2State{
	from
		linearactivity: BasicModel!Yield
	to
		state: EnrichedModel!YieldState
}

rule interruptActivity2YieldState  extends linearActivity2State{
	from
		linearactivity: BasicModel!Interrupt
	to
		state: EnrichedModel!InterruptState(
			interruptedThread <- thisModule.resolveTemp(linearactivity.interruptedThread, 'ThreadReference')	
		)
}

rule decisionActivity2State{
	from
		linearactivity: BasicModel!Decision
	to
		state: EnrichedModel!State(
			jumps <- linearactivity.branches->including(linearJump),
			id <- linearactivity.stateId
		),
		linearJump: EnrichedModel!Jump(
			nextState<-if linearactivity.nextActivity.oclIsKindOf(BasicModel!End) then OclUndefined else linearactivity.nextActivity endif
		)
}

rule forkActivity2ForkState{
	from
		forkActivity: BasicModel!Fork
	to
		state: EnrichedModel!ForkState(
			threadCount <- forkActivity.maxThreadCount,
			threadInits <- forkActivity.forkedThreads,
			id <- forkActivity.stateId
		)
			
}

rule branches2Jump{
	from
		branch: BasicModel!Branch
	to
		jump: EnrichedModel!Jump(
			condition <-branch.condition,
			nextState <-if branch.nextActivity.oclIsKindOf(BasicModel!End) then OclUndefined else branch.nextActivity endif
		)
}

rule forkedThread2threadInit{
	from
		forkedThread: BasicModel!ForkedThread
	to
		threadInit: EnrichedModel!ThreadInit(
			isDaemon <- forkedThread.daemon,
			calledMethod <- ForkedThreadMethod
		),
		ForkedThreadMethod: EnrichedModel!Method(
			name <- forkedThread.name + '(forked method)',
			states <- forkedThread.activities
		),
		ThreadReference: EnrichedModel!Thread(
			name<-forkedThread.name
		)
}













