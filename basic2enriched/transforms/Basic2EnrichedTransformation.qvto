modeltype BasicModel uses BasicModel;
modeltype EnrichedModel uses EnrichedModel;

transformation Basic2EnrichedTransformation(in basicModel : BasicModel, out enrichedModel: EnrichedModel);

property defaultInstanceType: EnrichedModel::InstanceType;
property staticThreads: Set(BasicModel::Thread);

main() {
	basicModel.rootObjects()[BasicModel::BasicModel]->asOrderedSet()->first()-> map model2model();
}

mapping BasicModel::BasicModel::model2model() : EnrichedModel::EnrichedModel {
	//Initialize list in which we store threads that are static
	//This list is used post-process
	staticThreads := Set{};
	
	//---------------------------------------------------------------------------------------------
	// Do the main chunk of the transformation from BasicModel to EnrichedModel
	//---------------------------------------------------------------------------------------------
	
	//Start by create the class that used when an object's instance type is null
	//'Main' and 'main' are invalid reference/activity names in BasicModel to allow for this class
	defaultInstanceType := object EnrichedModel::InstanceType {
		name := 'Main';
	};
	
	var childThreadsParam := object EnrichedModel::ChildThreadsParameter {
		name := "$childThreads";
	};
	
	var initialStateParam := object EnrichedModel::InitialStateParameter {
		name := "$initialState";
	};
	
	//Do the easily transformable lists (instance types, instances, shared resources)
	//References to (interruptable) threads will be done much later!
	instanceTypes+=defaultInstanceType;
	instanceTypes+=self.instanceTypes->map instanceType2instanceType();
	methodParameters+=self.instances->map instance2instance(); //Must be done AFTER instance types!
	methodParameters+=self.resources->map sharedResource2sharedResource();
	methodParameters+=childThreadsParam;
	methodParameters+=initialStateParam;
	
	//Transform all nested threads
	self.nestedThreads->map nestedThread2method();
	
	//Create the method for the main thread, and all threads that spawn from it, recursively
	var mainThread := self.map interruptableThread2thread(defaultInstanceType, true);
	
	//Create the main method, which calls the method for the main thread
	var mainMethod: EnrichedModel::Method := null;
	object mainMethod: EnrichedModel::Method {
		name := "main";
		defaultFirstState := object EnrichedModel::MethodCallState {
			method := mainMethod;
			calledMethod := mainThread.calledMethod;
			firstState := self.startActivity.resolveone(EnrichedModel::State);
		};
		variables := self.resources->resolve(EnrichedModel::SharedResource)->select(e| not e.isStatic);
		variables += self.instances->resolve(EnrichedModel::Instance)->select(e| not e.isStatic);
		states += defaultFirstState;
		isStatic := true;
	};
	defaultInstanceType.methods += mainMethod;
	
	//Add package name
	packageName := self.name;
	
	//Finally add the (interruptable) threads, now that we have them all
	methodParameters += BasicModel::InterruptableThread.allInstances().resolve(EnrichedModel::Thread);
	
	//---------------------------------------------------------------------------------------------
	// Post-processing! No more transformations are needed, but:
	//  - We may need extra objects
	//  - Clean up some lists
	//---------------------------------------------------------------------------------------------
	
	//Mark threads that are accessed statically by a Join/Interrupt at least once as static
	staticThreads->forEach(t) {
		t.resolveone(EnrichedModel::Thread).isStatic := true;
	};
	
	//Initialize method parameters and variables
	//We skip any method parameters that is static
	BasicModel::InterruptableThread.allInstances()->forEach(t) {
		var m := t.resolveone(EnrichedModel::Method);
		
		//Some threads are not called, they are executed by the current thread via a method call instead
		if (m != null) {
			m.parameters := t.startActivity.futureReferences->resolve(EnrichedModel::MethodParameter);
			m.variables := t.providedReferences.resolve(EnrichedModel::MethodParameter);
		} endif;
	};
	
	BasicModel::NestedThread.allInstances()->forEach(t) {
		var m := t.resolveone(EnrichedModel::Method);
		m.parameters := t.futureReferences->resolve(EnrichedModel::MethodParameter);
		m.variables := t.providedReferences.resolve(EnrichedModel::MethodParameter);
	};
	
	//Sort the lockedResources of all methods in the same order as they occur in methodParameters
	EnrichedModel::Method.allInstances()->forEach(m) {
		m.lockedResources->sortedBy(e | Sequence{1..methodParameters->size()}->select(i | methodParameters->at(i) = e)->first());
	};
	
	//Join objects can jump back to their own thread, which requires some more effort
	//Create extra method call states for the Join objects that need them
	//We do this here because creating extra states while iterating over them results in errors
	BasicModel::Join.allInstances()->forEach(basicJoin) {
		if (basicJoin.canJumpTo(basicJoin.nextActivity)) then {
			if (basicJoin.nextActivity.thread != basicJoin.thread) {
				var enrichedJoin := basicJoin.resolveone(EnrichedModel::JoinState);
				
				var methodCallState := object EnrichedModel::MethodCallState {
					method := enrichedJoin.method; 
					jumps := OrderedSet{};
					
					//We would not be able to resolve this in the mapping for Joins,
					//and we need its value in order to set calledMethod
					firstState := basicJoin.nextActivity.resolveone(EnrichedModel::State);
					targetInstance := basicJoin.nextActivity.instance.resolveone(EnrichedModel::Instance);
					calledMethod := firstState.method; //Do this after firstState has been resolved!
				};
				
				enrichedJoin.method.states += methodCallState;
				enrichedJoin.jumps := Sequence{object EnrichedModel::Jump {
					nextState := methodCallState;
				}};
			} endif;
		} endif;
	};
	
	//Interrupts are tricky too:
	// - When we interrupt a thread, we also interrupt all threads that it spawned
	// - When we interrupt a thread, any method called from within
	//   that thread can potentially throw the interrupted exception
	BasicModel::InterruptableThread.allInstances()->forEach(basicThread) {
		if (basicThread.isInterrupted) {
			var enrichedThread := basicThread.resolveone(EnrichedModel::Thread);
			
			if (enrichedThread != null) {
				var calledMethods := enrichedThread.calledMethod.GetCalledMethods(Set{});
				
				if (calledMethods->notEmpty() or enrichedThread.calledMethod.states->exists(s | s.oclIsTypeOf(EnrichedModel::SleepState) or s.oclIsTypeOf(EnrichedModel::JoinState))) {
					enrichedThread.calledMethod.catchesInterruptedException := true;
					enrichedThread.calledMethod.GetCalledMethods(Set{})->forEach(e) {
						if (enrichedThread.calledMethod != e) { 
							e.throwsInterruptedException := true;
						}
					};
				} endif; 
				
				if (basicThread.interruptedChildThreads->notEmpty()) {
					enrichedThread.calledMethod.hasChildThreadsVar := true;
					
					basicThread.interruptedChildThreads->forEach(basicInterruptedChild) {
						var enrichedInterruptedChild := basicInterruptedChild.resolveone(EnrichedModel::Thread);
						
						if (enrichedInterruptedChild != null) {
							if (not enrichedInterruptedChild.calledMethod.hasChildThreadsParam) {
								enrichedInterruptedChild.calledMethod.hasChildThreadsParam := true;
								enrichedInterruptedChild.calledMethod.parameters := enrichedInterruptedChild.calledMethod.parameters->including(childThreadsParam);
							} endif;
						} endif;
					};
				} endif;
			} endif;
		} endif;
	};
	
	//Set all states IDs
	//Tried doing this in EnrichedModel as a derived property, but Xpand did not like it
	EnrichedModel::State.allInstances()->forEach(s) {
		s.id := Sequence{1..s.method.states->size()}->select(i | s.method.states->at(i) = s)->first();
	};
	
	//Add auxiliary parameters
	EnrichedModel::Method.allInstances()->forEach(m) {
		if (not m.hasDynamicFirstState) {
			if (EnrichedModel::MethodCallState.allInstances()->select(e | e.calledMethod = m)->exists(e | e.firstState != m.defaultFirstState) or EnrichedModel::Thread.allInstances()->select(e | e.calledMethod = m)->exists(e | e.firstState != m.defaultFirstState)) {
				m.parameters := m.parameters->including(initialStateParam);
				m.hasDynamicFirstState := true;
			} endif;
		} endif;
	};
}

//Instance type
mapping BasicModel::InstanceType::instanceType2instanceType() : EnrichedModel::InstanceType {
	name := self.name;
}

query BasicModel::Activity::getInstanceType() : EnrichedModel::InstanceType {
	return if (self.instanceType = null) then defaultInstanceType else self.instanceType.resolveone(EnrichedModel::InstanceType) endif;
}

//Instance
mapping BasicModel::Instance::instance2instance() : EnrichedModel::Instance {
	name := self.name;
	isStatic := false; //In the future, the user may want to specify this
	
	//Instances are placed in the instance type (= class) equal to the type that they have.
	instanceType := self.instanceType.resolveone(EnrichedModel::InstanceType);
}

//Shared resource
mapping BasicModel::SharedResource::sharedResource2sharedResource() : EnrichedModel::SharedResource {
	name := self.name;
	isStatic := false; //In the future, the user may want to specify this
	
	//Shared resources are placed in the default instance type.
	instanceType := defaultInstanceType;
}

//Activity
mapping BasicModel::Activity::activity2state(m : EnrichedModel::Method) : EnrichedModel::State disjuncts
	BasicModel::SimpleActivity::simpleActivity2state, BasicModel::NestedActivity::nestedActivity2state,
	BasicModel::Sleep::sleepActivity2state, BasicModel::Yield::yieldActivity2state,
	BasicModel::Interrupt::interruptActivity2state, BasicModel::Decision::decisionActivity2state,
	BasicModel::Fork::forkActivity2state, BasicModel::Join::joinActivity2state,
	BasicModel::End::endActivity2state
{}

//End activity
mapping BasicModel::End::endActivity2state(m : EnrichedModel::Method) : EnrichedModel::State {
	method := m;
	jumps := OrderedSet{};
}

//Linear activitiy
abstract mapping BasicModel::LinearActivity::linearActivity2state(m : EnrichedModel::Method) : EnrichedModel::State {
	method := m;
	
	if (self.canJumpTo(self.nextActivity)) then {
		jumps := OrderedSet{object EnrichedModel::Jump {
			nextState := self.nextActivity.late resolveone(EnrichedModel::State);
		}};
	} else {
		jumps := OrderedSet{};
	} endif;
}

query BasicModel::Activity::canJumpTo(nextActivity : BasicModel::Activity) : Boolean {
	//Only go to a join if we are currently in the thread that is supposed to join
	//Other threads terminate, so that the joining will actually eventually happen
	if (nextActivity.oclIsKindOf(BasicModel::Join)) then {
		return nextActivity.thread = self.thread;
	} endif;
	
	//Jump to the next activity in all other cases
	return true;
}

//Simple activity
mapping BasicModel::SimpleActivity::simpleActivity2state(m : EnrichedModel::Method) : EnrichedModel::MethodCallState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::SimpleActivity) }
{
	//Determine in which instance type (= class) the method must be placed
	var it = self.getInstanceType();
	
	//Determine whether a method with the same name already exists in that instance type 
	var methodsWithSameName := it.methods->select(e | e.name = self.activityName);
	
	if (methodsWithSameName->isEmpty()) {
		calledMethod := object EnrichedModel::Method {
			name := self.activityName;
			firstState := null;
			states := OrderedSet{};
			hasDynamicFirstState := false;
			parameters := self.lockedResources->resolve(EnrichedModel::SharedResource);
			lockedResources := self.lockedResources->resolve(EnrichedModel::SharedResource);
			variables := OrderedSet{};
			isStatic := self.instanceType = null;
		};
		it.methods += calledMethod;
	} else {
		calledMethod := methodsWithSameName->first();
	} endif;
	
	firstState := null;
	
	if (self.instance != null) then {
		targetInstance := self.instance.resolveone(EnrichedModel::Instance); //Was created in the beginning
	} endif;
}

//Nested activity
mapping BasicModel::NestedActivity::nestedActivity2state(m : EnrichedModel::Method) : EnrichedModel::MethodCallState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::NestedActivity) }
{
	//Resolve late, because nested threads also transform states which access (non-existing) nested threads
	calledMethod := self.nestedThread.late resolveoneIn(BasicModel::NestedThread::nestedThread2method, EnrichedModel::Method);
	firstState := self.nestedThread.startActivity.late resolveone(EnrichedModel::State);
	
	if (self.nestedThread.startActivity.instance != null) {
		targetInstance := self.nestedThread.startActivity.instance.resolveone(EnrichedModel::Instance); //Was created in the beginning
	} endif;
}

mapping BasicModel::NestedThread::nestedThread2method() : EnrichedModel::Method {
	name := self.name;
	defaultFirstState := self.startActivity.late resolveone(EnrichedModel::State);
	hasDynamicFirstState := false;
	states := self.activities->map activity2state(result);
	lockedResources := self.lockedResources->resolve(EnrichedModel::SharedResource);
	isStatic := self.startActivity.instanceType = null;
	
	//Place the method in the instance type with the starting activity
	if (isStatic) then {
		defaultInstanceType.methods += result;
	} else {
		self.startActivity.getInstanceType().methods += result;
	} endif;
}

query EnrichedModel::Method::GetCalledMethods(soFar : Set(EnrichedModel::Method)) : Set(EnrichedModel::Method)
{
	var res: Set(EnrichedModel::Method) := Set{};
	
	if (soFar->includes(self)) {
		res := soFar;
	} else {
		res := soFar->including(self);
		
		self.states->forEach(state) {
			if (state.oclIsTypeOf(EnrichedModel::MethodCallState)) {
				res += state.oclAsType(EnrichedModel::MethodCallState).calledMethod.GetCalledMethods(res);
			} endif;
		};
	} endif;

	return res;
}

//Sleep
mapping BasicModel::Sleep::sleepActivity2state(m : EnrichedModel::Method) : EnrichedModel::SleepState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Sleep) }
{
	duration := self.duration;
}

//Yield
mapping BasicModel::Yield::yieldActivity2state(m : EnrichedModel::Method) : EnrichedModel::YieldState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Yield) }
{
	//Do nothing.
}

//Interrupt
mapping BasicModel::Interrupt::interruptActivity2state(m : EnrichedModel::Method) : EnrichedModel::InterruptState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Interrupt) }
{
	interruptedThread := self.interruptedThread.late resolveone(EnrichedModel::Thread);
	
	//If we cannot pass the interrupted thread to this state as a parameter, the thread must be made static
	//That also means that we will not know which instance of that thread we are interrupting
	terminateAll := self.siblingThreads->excludes(self.interruptedThread);
	
	if (terminateAll) {
		staticThreads += self.interruptedThread;
	} endif;
}

//Decision
mapping BasicModel::Decision::decisionActivity2state(m : EnrichedModel::Method) : EnrichedModel::State
	when { self.oclIsKindOf(BasicModel::Decision) }
{
	method := m;
	jumps := self.branches->map branch2jump(self);
	
	if (self.canJumpTo(self.nextActivity)) then {
		jumps += object EnrichedModel::Jump {
			nextState := self.nextActivity.late resolveone(EnrichedModel::State);
		};
	} endif;
}

mapping BasicModel::Branch::branch2jump(decision : BasicModel::Decision) : EnrichedModel::Jump {
	condition := self.condition;
	
	if (decision.canJumpTo(self.nextActivity)) {
		nextState := self.nextActivity.late resolveone(EnrichedModel::State);
	} endif;
}

//Fork
mapping BasicModel::Fork::forkActivity2state(m : EnrichedModel::Method) : EnrichedModel::ForkState
	when { self.oclIsKindOf(BasicModel::Fork) }
{
	method := m;
	threadCount := self.maxThreadCount;
	threadInits := self.forkedThreadsUsingThreadInit->map forkedThread2threadInit(self);
	jumps := self.forkedThreadsUsingJump->map forkedThread2jump();
}

mapping BasicModel::ForkedThread::forkedThread2threadInit(fork : BasicModel::Fork) : EnrichedModel::ThreadInit {
	isAdopted := fork.adoptedForkedThread = self;
	isDaemon := self.daemon;
	thread := self.map interruptableThread2thread(fork.getInstanceType(), fork.isVisitedOnce);
	
	//If a thread may be interrupted, AND if there may be multiple instances of that thread,
	//then that thread must be made static (so that all instances of the thread can be interrupted)
	if (BasicModel::Interrupt.allInstances()->exists(i | i.interruptedThread = self)) { //TODO or parents!
		if (not fork.isVisitedOnce) {
			staticThreads := staticThreads->including(self);
		} endif;
	} endif;
}

mapping BasicModel::ForkedThread::forkedThread2jump() : EnrichedModel::Jump {
	nextState := self.startActivity.late resolveone(EnrichedModel::State);
}

mapping BasicModel::InterruptableThread::interruptableThread2thread(enclosingInstanceType : EnrichedModel::InstanceType, isVisitedOnce : Boolean) : EnrichedModel::Thread {
	name := self.name;
	targetInstance := self.startActivity.instance.map instance2instance();
	firstState := self.startActivity.late resolveone(EnrichedModel::State);
	calledMethod := self.map interruptableThread2method();
	
	if (calledMethod.isStatic) then {
		defaultInstanceType.methods += calledMethod; 
	} else {
		self.startActivity.getInstanceType().methods += calledMethod;
	} endif;
	
	isStatic := false; //May be set to TRUE at the end of the transformation
	instanceType := enclosingInstanceType;
}

mapping BasicModel::InterruptableThread::interruptableThread2method() : EnrichedModel::Method {
	name := self.name;
	defaultFirstState := self.startActivity.late resolveone(EnrichedModel::State);
	states := self.activities->map activity2state(result);
	lockedResources := Set{};
	isStatic := self.startActivity.instanceType = null;
}

//Join
mapping BasicModel::Join::joinActivity2state(m : EnrichedModel::Method) : EnrichedModel::JoinState
	when { self.oclIsKindOf(BasicModel::Join) }
{
	method := m;
	joinedThreads += self.incomingThreads->late resolve(EnrichedModel::Thread);
	
	if (self.canJumpTo(self.nextActivity)) then {
		if (self.nextActivity.thread = self.thread) {
			//We stay in the same thread, so make a simple jump
			jumps := Sequence{object EnrichedModel::Jump {
				nextState := self.nextActivity.late resolveone(EnrichedModel::State);
			}};
		} else {
			//We want to call another method here, but we can only obtain this method
			//by late-resolving nextActivity and accessing its method field.
			//Since QVT does not like us accessing the field of a late-resolved object,
			//we do this at the very end of the transformation.
		} endif;
	} else {
		jumps := OrderedSet{};
	} endif;
}

