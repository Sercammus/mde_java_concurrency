modeltype BasicModel uses BasicModel;
modeltype EnrichedModel uses EnrichedModel;

transformation Basic2EnrichedTransformation(in basicModel : BasicModel, out enrichedModel: EnrichedModel);

property defaultInstanceType: EnrichedModel::InstanceType;
property staticThreads: Set(BasicModel::Thread);

main() {
	basicModel.rootObjects()[BasicModel::BasicModel]->asOrderedSet()->first()-> map model2model();
}

mapping BasicModel::BasicModel::model2model() : EnrichedModel::EnrichedModel {
	
	//Create a list of instance types (= classes)
	//Start by create the class with the program entry point
	//'Main' and 'main' are invalid reference/activity names in the basic model to allow for this class
	//The class also contains any shared resources (excepting threads)
	init {
		defaultInstanceType := object EnrichedModel::InstanceType {
			name := 'Main';
		};
		
		staticThreads := Set{};
	}
	
	//This is easy, because all of these things we will refer to later and not the other way around
	instanceTypes+=defaultInstanceType;
	instanceTypes+=self.instanceTypes->map instanceType2instanceType();
	methodParameters+=self.instances->map instance2instance();
	methodParameters+=self.resources->map sharedResource2sharedResource();
	
	//Transform all nested threads
	//Note that states must late-resolve nested threads because nested threads transform states that refer to nested threads! 
	self.nestedThreads->map nestedThread2method();
	
	//Create the main method from the main thread (and all threads that spawn from it, recursively)
	defaultInstanceType.methods += object EnrichedModel::Method {
		name := "main";
		firstState := self.startActivity.late resolveone(EnrichedModel::State);
		states := self.activities->map activity2state();
		isStatic := true;
	};
	
	//Make it possible to interrupt the main thread
	self.map interruptableThread2thread(defaultInstanceType, true);
	
	//Make a list of all method parameters that were used
	methodParameters += BasicModel::InterruptableThread.allInstances().resolveIn(BasicModel::Thread::interruptableThread2thread, EnrichedModel::Thread);
	
	end {
		staticThreads->forEach(t) {
			t.resolveone(EnrichedModel::Thread).isUsedAsParameter := false;
		};
	}
}

//Instance type
mapping BasicModel::InstanceType::instanceType2instanceType() : EnrichedModel::InstanceType {
	name := self.name;
}

query BasicModel::Activity::getInstanceType() : EnrichedModel::InstanceType {
	return if (self.instanceType = null) then defaultInstanceType else self.instanceType.resolveone(EnrichedModel::InstanceType) endif;
}

//Instance
mapping BasicModel::Instance::instance2instance() : EnrichedModel::Instance {
	name := self.name;
	isUsedAsParameter := true; //In the future, the user may want to specify this
	
	//Instances are placed in the instance type (= class) equal to the type that they have.
	instanceType := self.instanceType.resolveone(EnrichedModel::InstanceType);
	
	//TODO We need to know the contexts in which a combination of instances is synchronized
	//     We will do this in the third part of the project
}

//Shared resource
mapping BasicModel::SharedResource::sharedResource2sharedResource() : EnrichedModel::SharedResource {
	name := self.name;
	isUsedAsParameter := true; //In the future, the user may want to specify this
	
	//Shared resources are placed in the default instance type.
	instanceType := defaultInstanceType;
}

//Activity
mapping BasicModel::Activity::activity2state() : EnrichedModel::State disjuncts
	BasicModel::SimpleActivity::simpleActivity2state, BasicModel::NestedActivity::nestedActivity2state,
	BasicModel::Sleep::sleepActivity2state, BasicModel::Yield::yieldActivity2state,
	BasicModel::Interrupt::interruptActivity2state, BasicModel::Decision::decisionActivity2state,
	BasicModel::Fork::forkActivity2state, BasicModel::Join::joinActivity2state
{}

//Linear activitiy
abstract mapping BasicModel::LinearActivity::linearActivity2state() : EnrichedModel::State {
	if (self.canJumpTo(self.nextActivity)) then {
		jumps := Sequence{self.nextActivity.map nextActivity2jump()};
	} else {
		jumps := Sequence{};
	} endif;
}

query BasicModel::Activity::canJumpTo(nextActivity : BasicModel::Activity) : Boolean {
	//Do not jump to an end activity (since it does not do anything anyway)
	if (nextActivity.oclIsKindOf(BasicModel::End)) then {
		return false;
	} endif;
	
	//Only go to a join if we are currently in the thread that is supposed to join
	//Other threads terminate, so that the joining will actually eventually happen
	if (nextActivity.oclIsKindOf(BasicModel::Join)) then {
		return nextActivity.thread = self.thread;
	} endif;
	
	//Jump to the next activity in all other cases
	return true;
}

//NOTE: This is a separate method because QVTO does not like it if we modify a late-resolved value,
//      so we create the EnrichedModel::Jump immediately
mapping BasicModel::Activity::nextActivity2jump() : EnrichedModel::Jump {
	nextState := self.late resolveone(EnrichedModel::State);
}

//Simple activity
mapping BasicModel::SimpleActivity::simpleActivity2state() : EnrichedModel::MethodCallState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::SimpleActivity) }
{
	if (self.instance != null) then {
		targetInstance := self.instance.resolveone(EnrichedModel::Instance); //Was created in the beginning
	} endif;
	
	//Determine in which instance type (= class) the method must be placed
	var it = self.getInstanceType();
	
	//Determine whether a method with the same name already exists in that instance type 
	var methodsWithSameName := it.methods->select(e | e.name = self.activityName);
	
	if (methodsWithSameName->isEmpty()) {
		calledMethod := object EnrichedModel::Method {
			name := self.activityName;
			firstState := null;
			states := OrderedSet{};
			parameters := self.accessedReferences.late resolve(EnrichedModel::MethodParameter);
			isStatic := self.instanceType = null;
		};
		it.methods += calledMethod;
	} else {
		calledMethod := methodsWithSameName->first();
	} endif;
}

//Nested activity
mapping BasicModel::NestedActivity::nestedActivity2state() : EnrichedModel::MethodCallState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::NestedActivity) }
{
	//Resolve late, because nested threads also transform states which access (non-existing) nested threads
	calledMethod := self.nestedThread.late resolveoneIn(BasicModel::NestedThread::nestedThread2method, EnrichedModel::Method);
	
	if (self.nestedThread.startActivity.instance != null) {
		targetInstance := self.nestedThread.startActivity.instance.resolveone(EnrichedModel::Instance); //Was created in the beginning
	} endif;
}

mapping BasicModel::NestedThread::nestedThread2method() : EnrichedModel::Method {
	name := self.name;
	firstState := self.startActivity.late resolveone(EnrichedModel::State);
	states := self.activities->map activity2state();
	parameters := self.startActivity.accessedReferences.late resolve(EnrichedModel::MethodParameter);
	isStatic := self.startActivity.instanceType = null;
	
	//Place the method in the instance type with the starting activity
	if (isStatic) then {
		defaultInstanceType.methods += result;
	} else {
		self.startActivity.getInstanceType().methods += result;
	} endif;
}

//Sleep
mapping BasicModel::Sleep::sleepActivity2state() : EnrichedModel::SleepState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Sleep) }
{
	duration := self.duration;
}

//Yield
mapping BasicModel::Yield::yieldActivity2state() : EnrichedModel::YieldState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Yield) }
{
	//Do nothing.
}

//Interrupt
mapping BasicModel::Interrupt::interruptActivity2state() : EnrichedModel::InterruptState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Interrupt) }
{
	interruptedThread := self.interruptedThread.late resolveoneIn(BasicModel::Thread::interruptableThread2thread, EnrichedModel::Thread);
	
	//If we cannot pass the interrupted thread to this state as a parameter, the thread must be made static
	if (self.GetSiblingThreads()->excludes(self.interruptedThread)) {
		staticThreads += self.interruptedThread;
	} endif;
}

//Decision
mapping BasicModel::Decision::decisionActivity2state() : EnrichedModel::State
	when { self.oclIsKindOf(BasicModel::Decision) }
{
	jumps += self.branches->map branch2jump(self);
	
	if (self.canJumpTo(self.nextActivity)) then {
		jumps += Sequence{self.nextActivity.map nextActivity2jump()};
	} endif;
}

mapping BasicModel::Branch::branch2jump(decision : BasicModel::Decision) : EnrichedModel::Jump {
	condition := self.condition;
	
	if (decision.canJumpTo(self.nextActivity)) {
		nextState := self.nextActivity.late resolveone(EnrichedModel::State);
	} endif;
}

//Fork
mapping BasicModel::Fork::forkActivity2state() : EnrichedModel::ForkState
	when { self.oclIsKindOf(BasicModel::Fork) }
{
	threadCount := self.maxThreadCount;
	threadInits := self.forkedThreadsUsingThreadInit->map forkedThread2threadInit(self);
	jumps := self.forkedThreadsUsingJump->map forkedThread2jump();
}

mapping BasicModel::ForkedThread::forkedThread2threadInit(fork : BasicModel::Fork) : EnrichedModel::ThreadInit {
	isAdopted := fork.adoptedForkedThread = self;
	isDaemon := self.daemon;
	targetInstance := self.startActivity.instance.map instance2instance();
	
	//Create the method that the forked thread will execute
	calledMethod := object EnrichedModel::Method {
		name := self.name;
		firstState := self.startActivity.late resolveone(EnrichedModel::State);
		states := self.activities->map activity2state();
		parameters := self.startActivity.accessedReferences.late resolve(EnrichedModel::MethodParameter);
		isStatic := self.startActivity.instanceType = null;
	};
	
	//Place the thread method in the instance type with the starting activity
	if (calledMethod.isStatic) then {
		defaultInstanceType.methods += calledMethod; 
	} else {
		self.startActivity.getInstanceType().methods += calledMethod;
	} endif;
	
	//Create reference to the thread (so that is can be interrupted and joined with)
	thread := self.map interruptableThread2thread(fork.getInstanceType(), fork.isVisitedOnce);
}

mapping BasicModel::ForkedThread::forkedThread2jump() : EnrichedModel::Jump {
	nextState := self.startActivity.late resolveone(EnrichedModel::State);
}

mapping BasicModel::Thread::interruptableThread2thread(enclosingInstanceType : EnrichedModel::InstanceType, isVisitedOnce : Boolean) : EnrichedModel::Thread {
	name := self.name;
	instanceType := enclosingInstanceType;
	isMultiple := not isVisitedOnce;
	isUsedAsParameter := true; //May be set to false later
}

//Join
mapping BasicModel::Join::joinActivity2state() : EnrichedModel::JoinState
	inherits BasicModel::LinearActivity::linearActivity2state
	when { self.oclIsKindOf(BasicModel::Join) }
{
	joinedThreads += self.incomingThreads.late resolveIn(BasicModel::Thread::interruptableThread2thread, EnrichedModel::Thread);
	
	//If we cannot pass the incoming threads to this state as a parameters, the incoming threads must be made static
	(self.incomingThreads - self.thread.GetSiblingThreads())->forEach(t) {
		staticThreads := staticThreads->including(t);
	};
}

